/* Generated by Edge Impulse
*
* Permission is hereby granted, free of charge, to any person obtaining a copy
* of this software and associated documentation files (the "Software"), to deal
* in the Software without restriction, including without limitation the rights
* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
* copies of the Software, and to permit persons to whom the Software is
* furnished to do so, subject to the following conditions:
*
* The above copyright notice and this permission notice shall be included in
* all copies or substantial portions of the Software.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
* SOFTWARE.
*/
// Generated on: 10.02.2021 15:15:28

#include <stdio.h>
#include <stdlib.h>
#include <vector>
#include "edge-impulse-sdk/tensorflow/lite/c/builtin_op_data.h"
#include "edge-impulse-sdk/tensorflow/lite/c/common.h"
#include "edge-impulse-sdk/tensorflow/lite/micro/kernels/micro_ops.h"

#if defined __GNUC__
#define ALIGN(X) __attribute__((aligned(X)))
#elif defined _MSC_VER
#define ALIGN(X) __declspec(align(X))
#elif defined __TASKING__
#define ALIGN(X) __align(X)
#endif

namespace {

constexpr int kTensorArenaSize = 960;

#if defined(EI_CLASSIFIER_ALLOCATION_STATIC)
uint8_t tensor_arena[kTensorArenaSize] ALIGN(16);
#elif defined(EI_CLASSIFIER_ALLOCATION_STATIC_HIMAX)
#pragma Bss(".tensor_arena")
uint8_t tensor_arena[kTensorArenaSize] ALIGN(16);
#pragma Bss()
#else
#define EI_CLASSIFIER_ALLOCATION_HEAP 1
uint8_t* tensor_arena = NULL;
#endif

static uint8_t* tensor_boundary;
static uint8_t* current_location;

template <int SZ, class T> struct TfArray {
  int sz; T elem[SZ];
};
enum used_operators_e {
  OP_RESHAPE, OP_FULLY_CONNECTED, OP_ADD, OP_SOFTMAX,  OP_LAST
};
struct TensorInfo_t { // subset of TfLiteTensor used for initialization from constant memory
  TfLiteAllocationType allocation_type;
  TfLiteType type;
  void* data;
  TfLiteIntArray* dims;
  size_t bytes;
};
struct NodeInfo_t { // subset of TfLiteNode used for initialization from constant memory
  struct TfLiteIntArray* inputs;
  struct TfLiteIntArray* outputs;
  void* builtin_data;
  used_operators_e used_op_index;
};

TfLiteContext ctx{};
TfLiteTensor tflTensors[23];
TfLiteRegistration registrations[OP_LAST];
TfLiteNode tflNodes[11];

const TfArray<2, int> tensor_dimension0 = { 2, { 1,28 } };
const ALIGN(8) int32_t tensor_data1[2] = { -1, 56, };
const TfArray<1, int> tensor_dimension1 = { 1, { 2 } };
const ALIGN(8) int32_t tensor_data2[2] = { 7, 4, };
const TfArray<1, int> tensor_dimension2 = { 1, { 2 } };
const ALIGN(8) int32_t tensor_data3[3] = { 1, 7, 16, };
const TfArray<1, int> tensor_dimension3 = { 1, { 3 } };
const ALIGN(8) float tensor_data4[16] = { -0.87563103437423706, -0.21858157217502594, -0.93824911117553711, -0.30378887057304382, -1.48907470703125, -0.42124339938163757, 0.1919572502374649, -0.88044869899749756, -1.2546124458312988, -0.098195835947990417, -0.85982048511505127, -1.0494046211242676, 0.16183319687843323, -0.15577949583530426, 0.41998398303985596, -0.40955039858818054, };
const TfArray<1, int> tensor_dimension4 = { 1, { 16 } };
const ALIGN(8) int32_t tensor_data5[2] = { 7, 16, };
const TfArray<1, int> tensor_dimension5 = { 1, { 2 } };
const ALIGN(8) int32_t tensor_data6[3] = { 1, 7, 8, };
const TfArray<1, int> tensor_dimension6 = { 1, { 3 } };
const ALIGN(8) float tensor_data7[8] = { 0.80989980697631836, -0.30702850222587585, -0.35147365927696228, 0.58954834938049316, -0.5955541729927063, 0.7132948637008667, -0.89717686176300049, -0.028745606541633606, };
const TfArray<1, int> tensor_dimension7 = { 1, { 8 } };
const ALIGN(8) float tensor_data8[3] = { 0.96632117033004761, -0.2908758819103241, -0.85903513431549072, };
const TfArray<1, int> tensor_dimension8 = { 1, { 3 } };
const ALIGN(8) float tensor_data9[16*4] = { 
  -0.1042051687836647, -0.36930209398269653, 0.099979929625988007, -0.10429545491933823, 
  0.00043476274004206061, -0.26585188508033752, -0.0585746169090271, -0.0070505570620298386, 
  0.024483216926455498, -0.18460041284561157, 0.042632676661014557, -0.25413346290588379, 
  -0.38682940602302551, -0.22480066120624542, 0.23980879783630371, -0.3045402467250824, 
  -0.024497378617525101, -0.40344837307929993, 0.16717319190502167, -0.2055647075176239, 
  -0.0063976715318858624, -0.12166989594697952, -0.19623580574989319, -0.29387682676315308, 
  -0.18046663701534271, -0.17399312555789948, -0.27275761961936951, -0.0010429651010781527, 
  -0.1451009213924408, 0.0036891119088977575, 0.20492294430732727, -0.30485481023788452, 
  -0.069147840142250061, 0.069803595542907715, -0.53917235136032104, -0.002844509668648243, 
  -0.13783895969390869, -0.44437825679779053, -0.13906843960285187, -0.43487834930419922, 
  -0.46775615215301514, 0.46946856379508972, -0.38940054178237915, 0.00021816357912030071, 
  0.020567366853356361, 0.012422602623701096, -0.72621935606002808, 0.039774354547262192, 
  -0.016722988337278366, 0.014857002533972263, -0.52007979154586792, -0.10294931381940842, 
  -0.1164311096072197, 0.051205769181251526, -0.071792617440223694, -0.088249780237674713, 
  -0.096831880509853363, -0.50973886251449585, -0.17317362129688263, -0.066232740879058838, 
  -0.85517412424087524, 0.18785874545574188, -0.36276870965957642, 0.2042996734380722, 
};
const TfArray<2, int> tensor_dimension9 = { 2, { 16,4 } };
const ALIGN(8) float tensor_data10[8*16] = { 
  -0.13410139083862305, -0.50142884254455566, -0.32464560866355896, -0.25914132595062256, -0.4794984757900238, 0.2886354923248291, 0.79232680797576904, -0.2230408638715744, -0.24603870511054993, -0.10998024791479111, -0.4621608555316925, -0.19437985122203827, 0.26705652475357056, 0.024207960814237595, -0.49012872576713562, -0.00474513228982687, 
  -0.30791255831718445, -0.034292906522750854, 0.52456134557723999, -0.38212740421295166, -0.45808926224708557, 0.09247300773859024, -0.22803153097629547, -0.14511595666408539, -0.11249309033155441, 0.10416426509618759, -0.31313595175743103, 0.25237742066383362, 0.26431915163993835, -0.46510025858879089, -0.17343693971633911, -0.16510328650474548, 
  -0.7440260648727417, -0.015671133995056152, 0.13597492873668671, 0.048227187246084213, -0.77223086357116699, -0.12350127846002579, -0.29102492332458496, -0.01527249813079834, -0.082629173994064331, -0.028748273849487305, 0.040512405335903168, -0.57241696119308472, -0.34603214263916016, -0.23272478580474854, -0.46979176998138428, -0.16748224198818207, 
  -0.47523388266563416, -0.071847185492515564, -4.3016400337219238, -0.23543605208396912, 0.069473221898078918, -3.1922950744628906, -0.14729851484298706, 0.70268344879150391, -0.34081894159317017, -0.1081397533416748, 0.46837109327316284, -0.53914600610733032, -0.34160831570625305, 0.30778360366821289, 0.27657827734947205, 0.049197286367416382, 
  -0.005580150056630373, 0.3278275728225708, -0.35324174165725708, 0.00067902141017839313, 0.22530239820480347, -0.61400920152664185, -0.042504448443651199, -0.072720333933830261, 0.32129824161529541, 0.27003154158592224, -0.23407284915447235, 0.3440147340297699, -0.31264355778694153, 0.18182970583438873, 0.28544396162033081, -0.39828100800514221, 
  0.18473820388317108, -0.17367836833000183, -1.4493676424026489, 0.042468272149562836, -0.5199505090713501, -0.30636009573936462, 0.08613334596157074, 0.28406134247779846, 0.18657167255878448, -0.38877058029174805, 0.25736314058303833, -0.47466683387756348, -0.083274900913238525, -0.094390988349914551, 0.30776304006576538, -0.55115616321563721, 
  0.23042556643486023, -0.013153116218745708, -0.095940813422203064, 0.069232150912284851, 0.12124523520469666, 0.19557532668113708, 0.12289439886808395, -0.18467797338962555, -0.024679193273186684, -0.80199486017227173, -0.066758200526237488, 0.38014835119247437, -0.33147183060646057, -0.30076116323471069, 0.13536721467971802, -0.86166250705718994, 
  -0.35325378179550171, 0.34216511249542236, -0.36130613088607788, 0.094140872359275818, 0.25947755575180054, -0.15554995834827423, -0.13300104439258575, -0.066238038241863251, -0.27986714243888855, -0.2651066780090332, 0.17612987756729126, -0.51521849632263184, 0.2520519495010376, -0.37162518501281738, 0.12253298610448837, -0.33417162299156189, 
};
const TfArray<2, int> tensor_dimension10 = { 2, { 8,16 } };
const ALIGN(8) float tensor_data11[3*56] = { 
  2.0567066669464111, -0.24813924729824066, -0.28184157609939575, 1.6249569654464722, 0.17830367386341095, 1.1728960275650024, 0.16317185759544373, 0.33130666613578796, 2.0497837066650391, -0.038161635398864746, -0.056264340877532959, 0.062170423567295074, 0.048279259353876114, 0.19782082736492157, 0.11823273450136185, -0.097155764698982239, -0.13478338718414307, 0.086282558739185333, -0.22742113471031189, -0.58986961841583252, -0.028321409597992897, -0.1490226686000824, 0.11694879084825516, 0.010270467959344387, 0.9701082706451416, -0.19398388266563416, -0.0021217034664005041, -1.4313993453979492, 0.083083502948284149, 0.29234880208969116, -0.15987849235534668, -0.092382021248340607, 0.15751364827156067, 0.33343625068664551, 0.046384215354919434, -0.33787387609481812, -0.4977300763130188, 6.9717817306518555, -0.28840392827987671, 0.14985188841819763, -0.054871797561645508, -0.29635235667228699, 0.22383934259414673, 0.013855411671102047, 0.019625328481197357, -0.090972408652305603, -0.29768002033233643, 0.28268897533416748, 0.094983816146850586, -0.18311277031898499, 0.13997845351696014, 1.3389629125595093, -0.055650897324085236, 4.0416808128356934, -0.040199082344770432, 0.57066774368286133, 
  -1.1673152446746826, -0.055788397789001465, 0.26171028614044189, -1.3566722869873047, 0.1284988671541214, -0.83181947469711304, -0.03014027327299118, -0.11035417765378952, -4.2913322448730469, 0.032401382923126221, -0.27941817045211792, 0.066369436681270599, 0.3026752769947052, 0.083539329469203949, -0.1391400545835495, 0.052989412099123001, -0.30704066157341003, 0.27382206916809082, 0.02056487463414669, 0.68089485168457031, 0.14263202250003815, 0.60281932353973389, -0.1169755756855011, 0.13240377604961395, -2.0596325397491455, 0.12523724138736725, -0.42687141895294189, -3.2853133678436279, 0.14643318951129913, -0.18301364779472351, -0.048170179128646851, 0.070616297423839569, 0.080521970987319946, 0.27204713225364685, 0.22586297988891602, 0.18852448463439941, 0.042126983404159546, -4.7365274429321289, -0.10448865592479706, 0.12374911457300186, 0.018394935876131058, 0.023521900177001953, -0.033393356949090958, -1.0358656644821167, -0.19887162744998932, 0.042594410479068756, -0.061667591333389282, 0.09186650812625885, -0.10669251531362534, -0.50013881921768188, -0.11155311763286591, -0.26663288474082947, -0.30870011448860168, -0.55244386196136475, -0.040071979165077209, -0.44862186908721924, 
  -2.0424611568450928, -0.0652422234416008, 0.018775969743728638, -0.86648929119110107, 0.15216994285583496, -0.83816158771514893, -0.1220693439245224, -0.096671603620052338, -1.8131651878356934, -0.146731898188591, 0.048871099948883057, -0.16952298581600189, -0.22418706119060516, -0.15880860388278961, 0.012664176523685455, -0.20671577751636505, -0.2488638162612915, 0.33332768082618713, 0.28712373971939087, 0.011057798750698566, 0.27134144306182861, -0.1853162944316864, -0.16100901365280151, 0.076858103275299072, -0.78151088953018188, 0.094720125198364258, -0.066718354821205139, 1.9462971687316895, 0.099317491054534912, 0.021767793223261833, 0.25008153915405273, 0.10178269445896149, -0.1976192444562912, -0.052498038858175278, 0.26879656314849854, -0.12883515655994415, 0.23727641999721527, -5.1359939575195312, 0.19970378279685974, -0.15168730914592743, -0.043058883398771286, 0.012297153472900391, -0.0064051486551761627, 0.59135782718658447, -0.22629319131374359, -0.17125266790390015, 0.090522810816764832, 0.15409462153911591, -0.13669627904891968, 0.24913723766803741, -0.075149551033973694, -1.5595531463623047, -0.085295364260673523, -4.5990595817565918, 0.24268439412117004, -0.39365175366401672, 
};
const TfArray<2, int> tensor_dimension11 = { 2, { 3,56 } };
const TfArray<2, int> tensor_dimension12 = { 2, { 7,4 } };
const TfArray<2, int> tensor_dimension13 = { 2, { 7,16 } };
const TfArray<3, int> tensor_dimension14 = { 3, { 1,7,16 } };
const TfArray<3, int> tensor_dimension15 = { 3, { 1,7,16 } };
const TfArray<2, int> tensor_dimension16 = { 2, { 7,16 } };
const TfArray<2, int> tensor_dimension17 = { 2, { 7,8 } };
const TfArray<3, int> tensor_dimension18 = { 3, { 1,7,8 } };
const TfArray<3, int> tensor_dimension19 = { 3, { 1,7,8 } };
const TfArray<2, int> tensor_dimension20 = { 2, { 1,56 } };
const TfArray<2, int> tensor_dimension21 = { 2, { 1,3 } };
const TfArray<2, int> tensor_dimension22 = { 2, { 1,3 } };
const TfLiteReshapeParams opdata0 = { { 0, 0, 0, 0, 0, 0, 0, 0, }, 0 };
const TfArray<2, int> inputs0 = { 2, { 0,2 } };
const TfArray<1, int> outputs0 = { 1, { 12 } };
const TfLiteFullyConnectedParams opdata1 = { kTfLiteActNone, kTfLiteFullyConnectedWeightsFormatDefault, false, false };
const TfArray<3, int> inputs1 = { 3, { 12,9,-1 } };
const TfArray<1, int> outputs1 = { 1, { 13 } };
const TfLiteReshapeParams opdata2 = { { 0, 0, 0, 0, 0, 0, 0, 0, }, 0 };
const TfArray<2, int> inputs2 = { 2, { 13,3 } };
const TfArray<1, int> outputs2 = { 1, { 14 } };
const TfLiteAddParams opdata3 = { kTfLiteActRelu };
const TfArray<2, int> inputs3 = { 2, { 14,4 } };
const TfArray<1, int> outputs3 = { 1, { 15 } };
const TfLiteReshapeParams opdata4 = { { 0, 0, 0, 0, 0, 0, 0, 0, }, 0 };
const TfArray<2, int> inputs4 = { 2, { 15,5 } };
const TfArray<1, int> outputs4 = { 1, { 16 } };
const TfLiteFullyConnectedParams opdata5 = { kTfLiteActNone, kTfLiteFullyConnectedWeightsFormatDefault, false, false };
const TfArray<3, int> inputs5 = { 3, { 16,10,-1 } };
const TfArray<1, int> outputs5 = { 1, { 17 } };
const TfLiteReshapeParams opdata6 = { { 0, 0, 0, 0, 0, 0, 0, 0, }, 0 };
const TfArray<2, int> inputs6 = { 2, { 17,6 } };
const TfArray<1, int> outputs6 = { 1, { 18 } };
const TfLiteAddParams opdata7 = { kTfLiteActRelu };
const TfArray<2, int> inputs7 = { 2, { 18,7 } };
const TfArray<1, int> outputs7 = { 1, { 19 } };
const TfLiteReshapeParams opdata8 = { { 0, 0, 0, 0, 0, 0, 0, 0, }, 0 };
const TfArray<2, int> inputs8 = { 2, { 19,1 } };
const TfArray<1, int> outputs8 = { 1, { 20 } };
const TfLiteFullyConnectedParams opdata9 = { kTfLiteActNone, kTfLiteFullyConnectedWeightsFormatDefault, false, false };
const TfArray<3, int> inputs9 = { 3, { 20,11,8 } };
const TfArray<1, int> outputs9 = { 1, { 21 } };
const TfLiteSoftmaxParams opdata10 = { 1 };
const TfArray<1, int> inputs10 = { 1, { 21 } };
const TfArray<1, int> outputs10 = { 1, { 22 } };
const TensorInfo_t tensorData[] = {
  { kTfLiteArenaRw, kTfLiteFloat32, tensor_arena + 112, (TfLiteIntArray*)&tensor_dimension0, 112, },
  { kTfLiteMmapRo, kTfLiteInt32, (void*)tensor_data1, (TfLiteIntArray*)&tensor_dimension1, 8, },
  { kTfLiteMmapRo, kTfLiteInt32, (void*)tensor_data2, (TfLiteIntArray*)&tensor_dimension2, 8, },
  { kTfLiteMmapRo, kTfLiteInt32, (void*)tensor_data3, (TfLiteIntArray*)&tensor_dimension3, 12, },
  { kTfLiteMmapRo, kTfLiteFloat32, (void*)tensor_data4, (TfLiteIntArray*)&tensor_dimension4, 64, },
  { kTfLiteMmapRo, kTfLiteInt32, (void*)tensor_data5, (TfLiteIntArray*)&tensor_dimension5, 8, },
  { kTfLiteMmapRo, kTfLiteInt32, (void*)tensor_data6, (TfLiteIntArray*)&tensor_dimension6, 12, },
  { kTfLiteMmapRo, kTfLiteFloat32, (void*)tensor_data7, (TfLiteIntArray*)&tensor_dimension7, 32, },
  { kTfLiteMmapRo, kTfLiteFloat32, (void*)tensor_data8, (TfLiteIntArray*)&tensor_dimension8, 12, },
  { kTfLiteMmapRo, kTfLiteFloat32, (void*)tensor_data9, (TfLiteIntArray*)&tensor_dimension9, 256, },
  { kTfLiteMmapRo, kTfLiteFloat32, (void*)tensor_data10, (TfLiteIntArray*)&tensor_dimension10, 512, },
  { kTfLiteMmapRo, kTfLiteFloat32, (void*)tensor_data11, (TfLiteIntArray*)&tensor_dimension11, 672, },
  { kTfLiteArenaRw, kTfLiteFloat32, tensor_arena + 0, (TfLiteIntArray*)&tensor_dimension12, 112, },
  { kTfLiteArenaRw, kTfLiteFloat32, tensor_arena + 448, (TfLiteIntArray*)&tensor_dimension13, 448, },
  { kTfLiteArenaRw, kTfLiteFloat32, tensor_arena + 0, (TfLiteIntArray*)&tensor_dimension14, 448, },
  { kTfLiteArenaRw, kTfLiteFloat32, tensor_arena + 448, (TfLiteIntArray*)&tensor_dimension15, 448, },
  { kTfLiteArenaRw, kTfLiteFloat32, tensor_arena + 0, (TfLiteIntArray*)&tensor_dimension16, 448, },
  { kTfLiteArenaRw, kTfLiteFloat32, tensor_arena + 448, (TfLiteIntArray*)&tensor_dimension17, 224, },
  { kTfLiteArenaRw, kTfLiteFloat32, tensor_arena + 0, (TfLiteIntArray*)&tensor_dimension18, 224, },
  { kTfLiteArenaRw, kTfLiteFloat32, tensor_arena + 224, (TfLiteIntArray*)&tensor_dimension19, 224, },
  { kTfLiteArenaRw, kTfLiteFloat32, tensor_arena + 0, (TfLiteIntArray*)&tensor_dimension20, 224, },
  { kTfLiteArenaRw, kTfLiteFloat32, tensor_arena + 224, (TfLiteIntArray*)&tensor_dimension21, 12, },
  { kTfLiteArenaRw, kTfLiteFloat32, tensor_arena + 0, (TfLiteIntArray*)&tensor_dimension22, 12, },
};const NodeInfo_t nodeData[] = {
  { (TfLiteIntArray*)&inputs0, (TfLiteIntArray*)&outputs0, const_cast<void*>(static_cast<const void*>(&opdata0)), OP_RESHAPE, },
  { (TfLiteIntArray*)&inputs1, (TfLiteIntArray*)&outputs1, const_cast<void*>(static_cast<const void*>(&opdata1)), OP_FULLY_CONNECTED, },
  { (TfLiteIntArray*)&inputs2, (TfLiteIntArray*)&outputs2, const_cast<void*>(static_cast<const void*>(&opdata2)), OP_RESHAPE, },
  { (TfLiteIntArray*)&inputs3, (TfLiteIntArray*)&outputs3, const_cast<void*>(static_cast<const void*>(&opdata3)), OP_ADD, },
  { (TfLiteIntArray*)&inputs4, (TfLiteIntArray*)&outputs4, const_cast<void*>(static_cast<const void*>(&opdata4)), OP_RESHAPE, },
  { (TfLiteIntArray*)&inputs5, (TfLiteIntArray*)&outputs5, const_cast<void*>(static_cast<const void*>(&opdata5)), OP_FULLY_CONNECTED, },
  { (TfLiteIntArray*)&inputs6, (TfLiteIntArray*)&outputs6, const_cast<void*>(static_cast<const void*>(&opdata6)), OP_RESHAPE, },
  { (TfLiteIntArray*)&inputs7, (TfLiteIntArray*)&outputs7, const_cast<void*>(static_cast<const void*>(&opdata7)), OP_ADD, },
  { (TfLiteIntArray*)&inputs8, (TfLiteIntArray*)&outputs8, const_cast<void*>(static_cast<const void*>(&opdata8)), OP_RESHAPE, },
  { (TfLiteIntArray*)&inputs9, (TfLiteIntArray*)&outputs9, const_cast<void*>(static_cast<const void*>(&opdata9)), OP_FULLY_CONNECTED, },
  { (TfLiteIntArray*)&inputs10, (TfLiteIntArray*)&outputs10, const_cast<void*>(static_cast<const void*>(&opdata10)), OP_SOFTMAX, },
};
static std::vector<void*> overflow_buffers;
static TfLiteStatus AllocatePersistentBuffer(struct TfLiteContext* ctx,
                                                 size_t bytes, void** ptr) {
  if (current_location - bytes < tensor_boundary) {
    // OK, this will look super weird, but.... we have CMSIS-NN buffers which
    // we cannot calculate beforehand easily.
    *ptr = malloc(bytes);
    if (*ptr == NULL) {
      printf("ERR: Failed to allocate persistent buffer of size %d\n", (int)bytes);
      return kTfLiteError;
    }
    overflow_buffers.push_back(*ptr);
    return kTfLiteOk;
  }

  current_location -= bytes;

  *ptr = current_location;
  return kTfLiteOk;
}
typedef struct {
  size_t bytes;
  void *ptr;
} scratch_buffer_t;
static std::vector<scratch_buffer_t> scratch_buffers;

static TfLiteStatus RequestScratchBufferInArena(struct TfLiteContext* ctx, size_t bytes,
                                                int* buffer_idx) {
  scratch_buffer_t b;
  b.bytes = bytes;

  TfLiteStatus s = AllocatePersistentBuffer(ctx, b.bytes, &b.ptr);
  if (s != kTfLiteOk) {
    return s;
  }

  scratch_buffers.push_back(b);

  *buffer_idx = scratch_buffers.size() - 1;

  return kTfLiteOk;
}

static void* GetScratchBuffer(struct TfLiteContext* ctx, int buffer_idx) {
  if (buffer_idx > static_cast<int>(scratch_buffers.size()) - 1) {
    return NULL;
  }
  return scratch_buffers[buffer_idx].ptr;
}
} // namespace

  TfLiteStatus trained_model_init( void*(*alloc_fnc)(size_t,size_t) ) {
#ifdef EI_CLASSIFIER_ALLOCATION_HEAP
  tensor_arena = (uint8_t*) alloc_fnc(16, kTensorArenaSize);
  if (!tensor_arena) {
    printf("ERR: failed to allocate tensor arena\n");
    return kTfLiteError;
  }
#endif
  tensor_boundary = tensor_arena;
  current_location = tensor_arena + kTensorArenaSize;
  ctx.AllocatePersistentBuffer = &AllocatePersistentBuffer;
  ctx.RequestScratchBufferInArena = &RequestScratchBufferInArena;
  ctx.GetScratchBuffer = &GetScratchBuffer;
  ctx.tensors = tflTensors;
  ctx.tensors_size = 23;
  for(size_t i = 0; i < 23; ++i) {
    tflTensors[i].type = tensorData[i].type;
    tflTensors[i].is_variable = 0;

#if defined(EI_CLASSIFIER_ALLOCATION_HEAP)
    tflTensors[i].allocation_type = tensorData[i].allocation_type;
#else
    tflTensors[i].allocation_type = (tensor_arena <= tensorData[i].data && tensorData[i].data < tensor_arena + kTensorArenaSize) ? kTfLiteArenaRw : kTfLiteMmapRo;
#endif
    tflTensors[i].bytes = tensorData[i].bytes;
    tflTensors[i].dims = tensorData[i].dims;

#if defined(EI_CLASSIFIER_ALLOCATION_HEAP)
    if(tflTensors[i].allocation_type == kTfLiteArenaRw){
      uint8_t* start = (uint8_t*) ((uintptr_t)tensorData[i].data + (uintptr_t) tensor_arena);

     tflTensors[i].data.data =  start;
    }
    else{
       tflTensors[i].data.data = tensorData[i].data;
    }
#else
    tflTensors[i].data.data = tensorData[i].data;
#endif // EI_CLASSIFIER_ALLOCATION_HEAP
    tflTensors[i].quantization.type = kTfLiteNoQuantization;
    if (tflTensors[i].allocation_type == kTfLiteArenaRw) {
      auto data_end_ptr = (uint8_t*)tflTensors[i].data.data + tensorData[i].bytes;
      if (data_end_ptr > tensor_boundary) {
        tensor_boundary = data_end_ptr;
      }
    }
  }
  if (tensor_boundary > current_location /* end of arena size */) {
    printf("ERR: tensor arena is too small, does not fit model - even without scratch buffers\n");
    return kTfLiteError;
  }
  registrations[OP_RESHAPE] = *tflite::ops::micro::Register_RESHAPE();
  registrations[OP_FULLY_CONNECTED] = *tflite::ops::micro::Register_FULLY_CONNECTED();
  registrations[OP_ADD] = *tflite::ops::micro::Register_ADD();
  registrations[OP_SOFTMAX] = *tflite::ops::micro::Register_SOFTMAX();

  for(size_t i = 0; i < 11; ++i) {
    tflNodes[i].inputs = nodeData[i].inputs;
    tflNodes[i].outputs = nodeData[i].outputs;
    tflNodes[i].builtin_data = nodeData[i].builtin_data;
    tflNodes[i].custom_initial_data = nullptr;
    tflNodes[i].custom_initial_data_size = 0;
    if (registrations[nodeData[i].used_op_index].init) {
      tflNodes[i].user_data = registrations[nodeData[i].used_op_index].init(&ctx, (const char*)tflNodes[i].builtin_data, 0);
    }
  }
  for(size_t i = 0; i < 11; ++i) {
    if (registrations[nodeData[i].used_op_index].prepare) {
      TfLiteStatus status = registrations[nodeData[i].used_op_index].prepare(&ctx, &tflNodes[i]);
      if (status != kTfLiteOk) {
        return status;
      }
    }
  }
  return kTfLiteOk;
}

static const int inTensorIndices[] = {
  0, 
};
TfLiteTensor* trained_model_input(int index) {
  return &ctx.tensors[inTensorIndices[index]];
}

static const int outTensorIndices[] = {
  22, 
};
TfLiteTensor* trained_model_output(int index) {
  return &ctx.tensors[outTensorIndices[index]];
}

TfLiteStatus trained_model_invoke() {
  for(size_t i = 0; i < 11; ++i) {
    TfLiteStatus status = registrations[nodeData[i].used_op_index].invoke(&ctx, &tflNodes[i]);
    if (status != kTfLiteOk) {
      return status;
    }
  }
  return kTfLiteOk;
}

TfLiteStatus trained_model_reset( void (*free_fnc)(void* ptr) ) {
#ifdef EI_CLASSIFIER_ALLOCATION_HEAP
  free_fnc(tensor_arena);
#endif
  scratch_buffers.clear();
  for (size_t ix = 0; ix < overflow_buffers.size(); ix++) {
    free(overflow_buffers[ix]);
  }
  overflow_buffers.clear();
  return kTfLiteOk;
}
